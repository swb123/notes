## 锁

### 什么是锁

&emsp;锁是数据库系统区别于文件系统的一个关键特性。锁机制用于管理对共享资源的并发访问。InnoDB存储引擎会在行级别上对表数据上锁，从而允许对多种不同资源提供并发访问。

&emsp;对于MyISAM引擎，其锁是表锁设计。并发情况下的读没有问题，但是并发插入时的性能就要差一些了。

#### lock 与 latch

&emsp;latch一般称为门（中间加一杠）锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

&emsp;lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。

![1572061547879](C:\Users\施文波\AppData\Roaming\Typora\typora-user-images\1572061547879.png)

### InnoDB存储引擎中的锁

#### 锁的类型

&emsp;InnoDB存储引擎实现了如下两种标准的行级锁：

+ 共享锁（S Lock），允许事务读一行数据。
+ 排他锁 （X Lock），允许事务删除或更新一行数据。

&emsp;如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他事务T3想获得r的排他锁，则必须等待事务T1、T2释放r上的共享锁------这种情况称为锁不兼容。

![1572062037906](C:\Users\施文波\AppData\Roaming\Typora\typora-user-images\1572062037906.png)

&emsp;从上表可以看出，X锁与任何的锁都不兼容，而S锁仅和S锁兼容。

> S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况。

&emsp;InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。

&emsp;若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如下图所示，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。

![1572062705744](C:\Users\施文波\AppData\Roaming\Typora\typora-user-images\1572062705744.png)

&emsp;若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。

&emsp;InnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：

1）意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁

2）意向排他锁（IX Lock) ，事务想要获得一张表中某几行的排他锁

&emsp;由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如下表所示。

![1572063305581](C:\Users\施文波\AppData\Roaming\Typora\typora-user-images\1572063305581.png)

#### 一致性非锁定读

&emsp;一致性的非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎回去读取行的一个快照数据。如图所示，

![1572063727494](C:\Users\施文波\AppData\Roaming\Typora\typora-user-images\1572063727494.png)

&emsp;之所以称其为非锁定读，因为不需要等待访问的行上X锁的释放。快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。而undo用来在事务中回滚数据。因此快照数据本身是没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。

&emsp;一个行记录可能有不止一个快照数据，一般称这种技术为行多版本技术。由此带来的并发控制，称之为多版本并发控制（Multi Version Concurrency Control, MVCC）。

&emsp;在事务隔离级别READ COMMITTED和REPEATABLE READ(InnoDB 存储引擎的默认事务隔离级别)下，InnoDB存储引擎使用非锁定的一致性读。然而，对于快照数据的定义却不相同。在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本。

#### 一致性锁定读

&emsp;在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT 操作使用一致性非锁定读。但是在某些情况下，用户需要显式地对数据库读取操作进行加锁以保证数据逻辑的一致性。

&emsp;InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：

+ SELECT …… FOR UPDATE
+ SELCT …… LOCK IN SHARE MODE

&emsp;SELECT ……FOR UPDATE对读取的行记录加一个X锁，其他事务不能对已锁定的行加上任何锁。SELECT……LOCK IN SHARE MODE对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X锁，则会被阻塞。

&emsp;对于一致性非锁定读，即使读取的行已被执行了SELECT……FOR UPDATE，也是可以进行读取的，这和之前讨论的情况一样。此外，SELECT……FOR UPDATE , SELECT ……LOCK IN SHARE MODE必须在一个事务中，当事务提交了，锁也就释放了。

#### 自增长与锁

&emsp;AUTO-INC Locking , 其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的SQL语句后立即释放。

#### 外键和锁

&emsp;在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDB存储引擎自动对其加一个索引，因为这样可以避免表锁。

### 锁的算法

#### 行锁的3种算法

&emsp;InnoDB存储引擎有3种行锁的算法，其分别是：

+ Record Lock：单个行记录上的锁
+ Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
+ Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

&emsp;Record Lock总是回去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有甚至任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。

&emsp;Next-Key Lock是结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。

&emsp;采用Next-Key Lock的锁定技术称为Next-Key  Locking。其设计的目的是为了解决Phantom Problem，利用这种锁定技术，锁定的不是单个值，而是一个范围，是谓词锁（predict lock）的一种改进。

&emsp;当查询的索引含有唯一属性是，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。

#### Phantom Problem

&emsp;在默认的事务隔离级别下，即REPETABLE READ下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem(幻像问题)。

> Phantom Problem是指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

InnoDB存储引擎默认的事务隔离级别是REPETABLE READ，在该隔离级别下，其采用Next-Key Locking的方式来加锁。而在事务隔离级别READ COMMITTED下，其仅采用Record Lock。

### 锁问题

&emsp;通过锁定机制可以实现事务的隔离性要求，使得事务可以并发地工作。锁提高了并发，但是却会带来潜在的问题。不过好在因为事务隔离性的要求，锁只会带来三种问题，如果可以防止这三种情况的发生，那将不会产生并发异常。

#### 脏读

&emsp;脏数据和之前的脏页完全是两种不同的概念。脏页指的是缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的，当然在刷新到磁盘之前，日志都已经被写入到了重做日志文件中。而所谓脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。

&emsp;脏页是因为数据库实例内存和磁盘的异步造成的，这并不影响数据的一致性（或者说两者最终会达到一致性，即当脏页都刷回磁盘）。并且因为脏页的刷新是异步的，不影响数据库的可用性，因此可以带来性能的提高。

&emsp;脏数据却截然不同，脏数据是指未提交的数据，如果读到了脏数据，即一个事务可以读到另外一个事务中为提交的数据，则显然违反了数据库的隔离性。

&emsp;脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，即脏数据。

#### 不可重复读

&emsp;不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务到两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的树是不一样的情况，这种情况称为不可重复读。

&emsp;不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。

&emsp;一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据，本身并不会带来很大的问题。因此，很多数据库产商（如Oracle、Microsoft SQL Server）将其数据库事务的默认隔离级别设置为READ COMMITTED，在这种隔离级别下允许不可重复读的现象。

&emsp;在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。在MySQL官方文档中将不可重复读的问题定义为Phantom Problem，即幻像问题。在Next-Key Lock算法下，对于索引的扫描，不仅是锁住扫描的索引，而且还锁住这些索引覆盖的范文（gap）。因此在这个范围内的插入都是不允许的。这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。因此，InnoDB存储引擎的默认事务隔离级别是READ REPEATABLE，采用Next-Key Lock算法，避免了不可重复读的现象。

#### 丢失更新

&emsp;丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。

&emsp;但是，在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。这是因为，即使READ UNCOMMITTED的事务隔离级别，对于行的DML操作，需要对行或其他粗粒度级别的对象加锁。

&emsp;虽然数据库能够阻止丢失更新问题的产生，但是在生产应用中还有另一个逻辑意义的丢失更新问题，而导致该问题的并不是因为数据库本身的问题。

&emsp;要避免丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行的操作。即给记录加上排他锁。

### 阻塞

&emsp;因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞并不是一件坏事，其是为了确保事务可以并发且正常的运行。

### 死锁

#### 死锁的概念

&emsp;死锁是指两个或两个以上的事务在执行过程中，因争夺所资源而造成的一种互相等待的现象。若无外力作用，事务都无法推进下去，解决死锁问题最简单的方式不要有等待，将任何的等待都转化为回滚，并且事务重新开始。这可能导致并发性能的下降，甚至任何一个事务都不能进行。

&emsp;解决死锁问题的最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。

&emsp;超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据FIFO的顺序选择回滚对象。但若超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的undo log，这时采用FIFO的方式，就不合适了， 因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。

&emsp;因此，除了超时机制，当前数据库还都普遍采用wait-for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB存储引擎也采用的这种方式。wait-for-graph要求数据库保存以下两种信息：

+ 锁的信息链表
+ 事务的等待链表

通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。通常来说，InnoDB存储引擎选择回滚undo量最小的事务。

### 锁升级

&emsp;锁升级（Lock Escalation）是指档期那锁的锁的粒度降低。

&emsp;InnoDB存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。















