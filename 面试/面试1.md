1. 事务的4个隔离等级

   + `读未提交`（Read uncommitted），一个事务可以读取另一个未提交事务的数据。会出现`脏读`。

   + `读提交`（Read Committed）一个事务要等另一个事务提交后才能读取数据。解决了`脏读`，但出现了`不可重复读`，即一个事务范围内两个相同的查询却返回了不同数据。

   + `重复读` (Repetable read)，就是开始读取数据（事务开启）时，不再允许修改操作。可以解决`不可重复读`问题，但是可能会有`幻读`问题，因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。MySQL用next-key locking解决。

   + 串行化（Serializable）

     最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复度与幻读。

2. servlet四个生命周期

   + 被创建：加载servlet的class，实例化servlet，执行init方法，只执行一次
   + 提供服务：执行service方法（doGet和doPost方法），执行多次
   + 被销毁：当Servlet服务器正常关闭时，执行destroy方法，只执行一次

3. 一千万数据前100份数据排序

   利用哈希函数分流，分到不同机器，拆分成更小的文件，使用大小为100的小根堆来选出每个小文件的Top100，然后把各个小文件排序后的top100进行外排序或者继续利用小根堆，就可以选出每台机器上的top100。不同机器之间的Top100再进行外排序或者继续利用小根堆，最终求出整个数据量中的Top100.

4. Mysql索引 

5. Redis 为什么高性能，单线程

   多路复用I/O模型，

   完全基于内存，

   使用单线程，避免了不必要的上下文切换和竞争锁机制，

6. HashMap 数组大小，链表大小

7. TreeMap

8. sql注入