## 滴滴

动态代理：实现JDK

 https://www.itcodemonkey.com/article/9285.html 

Http2.0

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能

### Https和Http的区别

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。

- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。

- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

  ### HTTP1.0和HTTP1.1的一些区别

  HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

  1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
  2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
  4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
  5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

  

### 多叉树的遍历：最大深度

#### 二叉树

class Solution {

  public int maxDepth(TreeNode root) {

​    if(root == null)

​      return 0;

​    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));

​    

  }

}

### 多叉树

/*

// Definition for a Node.

class Node {

  public int val;

  public List<Node> children;



  public Node() {}



  public Node(int _val,List<Node> _children) {

​    val = _val;

​    children = _children;

  }

};

*/

class Solution {

  private int ans = 0;

  public int maxDepth(Node root) {

​    if(root != null)

​    {

​      traverse(root, 1);

​    }

​    return ans;

  }

  private void traverse(Node root,int i){

​    if(root != null){

​      ans = Math.max(ans,i);

​      for(Node e : root.children)

​      {

​        traverse(e,i+1);

​      }

​    }

  }

}

### 快排的优化

 **1.随机选取法** 

　　引入原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴

　　思路：使用随机数生成函数生成一个随机数rand，随机数的范围为[left, right]，并用此随机数为下标对应的元素a[rand]作为中轴，并与最后一个元素a[right]交换，然后进行 与选取最后一个元素作为中轴的快排一样的算法即可。 

 　　优点：这是一种相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2^n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。 

2.三数取中（median-of-three

　　**引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了\**三数取中\**选取枢轴**

　　**思路：**假设数组被排序的范围为left和right，center=（left+right）/2，对a[left]、a[right]和a[center]进行适当排序，取中值为中轴，将最小者放a[left]，最大者放在a[right]，把中轴元与a[right-1]交换，并在分割阶段将i和j初始化为left+1和right-2。然后使用双向描述法，进行快排。

　　分割好处：　　　　　　

　　　　1.将三元素中最小者被分到a[left]、最大者分到a[right]是正确的，因为当快排一趟后，比中轴小的放到左边，而比中轴大的放到右边，这样就在分割的时候把它们分到了正确的位置，减少了一次比较和交换。

　　　　2.在前面所说的所有算法中，都有双向扫描时的越界问题，而使用这个分割策略则可以解决这个问题。因为i向右扫描时，必然会遇到不小于中轴的数a[right-1]，而j在向左扫描时，必然会遇到不大于中轴的数a[left]，这样，a[right-1]和a[left]提供了一个警戒标记，所以不需要检查下标越界的问题。

　　分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数。

#### 进一步优化

上述三种快排，在处理重复数的时候，效率并没有很大提高，因此，我们可以想办法优化。

1.当待排序序列长度分割到一定大小后，使用插入排序。

　　　原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。

2.在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割（处理重复效率极高）　

具体过程：在处理过程中，会有两个步骤

　　　　第一步，在划分过程中，把与key相等元素放入数组的两端

　　　　第二步，划分结束后，把与key相等的元素移到枢轴周围

 3.优化递归操作　

　　快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化

优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。

### 虚引用和软引用，弱引用，强引用

强引用：类似“Object obj = new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

软引用：用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference类实现软引用。

弱引用：强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集器发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在WeakReferance类实现弱引用。

虚引用：被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取的一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 PhantomReference类来实现引用。



HashMap和CourentHashMap 源码

IOC和AOP 源码



### FullGC和Minor GC

什么时候频繁fullgc，如果代码没有问题？

QPS很高；

老年代设置问题。

 ### String a = New string ("a");在jvm中如何存储？

### volatile

### Java内存泄露

### Java线程池



